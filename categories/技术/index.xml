<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术 on 好事发生</title>
    <link>https://blog.hanyu.me/categories/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on 好事发生</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Jul 2024 17:51:21 +0800</lastBuildDate>
    <atom:link href="https://blog.hanyu.me/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>要使用业务唯一ID做主键吗？</title>
      <link>https://blog.hanyu.me/tech/4/</link>
      <pubDate>Thu, 04 Jul 2024 17:51:21 +0800</pubDate>
      <guid>https://blog.hanyu.me/tech/4/</guid>
      <description>注意：&#xA;本篇文章需阅读者掌握MySQL索引基本原理，可提前阅读 MySQL系列 | 浅尝MySQL索引 本篇文章涉及的V2帖子，没有特殊能力者，是访问不通的 本人无特殊能力去看V2帖子，是不小心在某个地方看到，已全然忘记出处，是一位遵纪守法的好公民 看到V2一篇帖子中的提问：https://go.lion.im/sk7qf ，促使我写下了这篇文章。&#xA;这位楼主的问题看似简单，但挺值得思考的。&#xA;这个问题我曾经想当然的认为，答案就应该是“需要使用自增ID列作为主键”，直到曾经一次滴滴的面试，被问到几乎同样的问题，才进行了深度的思考。&#xA;很多时候我们在设计数据库表的时候，明明已经有了一个逻辑上的唯一ID，却依然新建了一个自增的ID作为物理主键，在业务上却毫无用处，仿佛就像人要吃饭睡觉一样自然，why?&#xA;非自增主键会产生的问题 我们先来看看，为什么我们需要一个自增的主键？&#xA;性能问题 MySQL InnoDB 引擎的主键索引是一棵B+树结构，为了维护索引数据的有序性，会对新增数据进行比较，如果大于最大值，则只需要在最后记录后面插入一个新记录，如果小于，那么会去查找应该插入的具体位置。&#xA;页分裂 由于数据页的大小默认是16KB，如果恰巧要插入数据的数据页已满，就需要在此位置申请一个新的数据页，然后迁移部分数据过去，这个过程称为页分裂。&#xA;所以，如果我们的主键是自增的，那么每次新增数据，都会直接在最大记录后插入，非常高效。&#xA;空间问题 页空洞 如果主键是非自增的，除了要在插入过程中，经过多次比较、页分裂导致数据挪动等额外的耗时操作外，还会产生页空洞，致使空间利用率下降。&#xA;辅助索引 当我们为了高效多维度查询，对一张表创建了多个辅助索引时，辅助索引的叶子节点存储的是主键值。&#xA;如果我们使用业务上的唯一ID来做主键，由于一般业务上的唯一ID为了保证唯一性，生成的ID可能较长，那么所有辅助索引的叶子节点数据都会变大。 例如，用18位身份证号做主键，刨除其他额外信息，需要18个字节，而如果使用整型自增，则只需要4字节。&#xA;综上来看，无论是从性能上，还是空间占用上，我们确实应该使用自增ID列做主键，而不应该使用业务唯一ID来做主键。&#xA;那么，所有场景都该如此吗？不，当然不是。&#xA;业务唯一ID适合作为主键的场景 什么场景下，我们可以使用业务唯一ID来做主键呢？&#xA;有限场景一 业务唯一ID必须是自增趋势的 只会有一个主键索引 如果同时满足以上两点，那么使用业务唯一ID作为主键是最佳的。&#xA;因为如果此时，再去建立自增ID列，那么必然要基于业务唯一ID建立辅助索引，我们知道，由于自增ID是不会在业务中被使用的，所以我们的查询，都要基于业务唯一ID来进行，这样将会在每次查询时，造成回表。&#xA;所以，使用业务唯一ID作为主键既避免了回表操作，又保证了主键的递增趋势，也不需要创建辅助索引，一举三得。&#xA;有限场景二 读多写少 数据量小 假设你的业务唯一ID不是自增趋势，是否可以使用它做主键呢？&#xA;答案是可以。&#xA;但要满足以上两个条件，第一是，这张表，必须是读多写少的，例如我曾在一家在线教育公司任职，课程产品表，就是一个读多写极少，且数据量很小的表，即使课程唯一ID无序，也完全可以作为主键，对性能几乎无影响，新增频率极低。&#xA;总结 其实当我们的软硬件资源足够充沛，并可预见的能持续保持时，我们可以减少一些开发、设计细节上的斟酌和处理，但是，思考却不能敷衍。&#xA;不同的外部条件下，我们的行为可能会做出调整或取舍，但思考必须是细致的、全面的、尽力的，为作品，也为自己的成长。&#xA;个人博客：HanYu.me&#xA;技术网站：404.site&#xA;公众号： 今天404</description>
    </item>
    <item>
      <title>高并发短链系统设计</title>
      <link>https://blog.hanyu.me/tech/3/</link>
      <pubDate>Thu, 04 May 2023 10:01:22 +0800</pubDate>
      <guid>https://blog.hanyu.me/tech/3/</guid>
      <description>原则与底线：不说废话、不凑字数、不标题党。&#xA;注：本文均为韩宇的胡思乱写，你随便抄&#xA;背景 什么是短链 一个长的网址链接，转换为一个短的网址链接。&#xA;比如我发微博内容带有 https://blog.hanyu.cool/about/ 链接时，链接会自动转换成 https://t.cn/A6NlWmYi 这样的短网址。&#xA;微博的短网址域名为：t.cn，腾讯的短网址域名为 url.cn，阅读本文后，就可以自己实现一个高性能短链服务。&#xA;短链的作用 缩减无意义的地址长度，多出空间给实际内容（当前微博限制5000个字） 对URL进行流控、点击统计，来源识别等，方便进行数据分析 防止直接暴露参数等信息，防止某些平台对参数中的关键词屏蔽 方便对URL进行封禁，相同URL通过生成转换之后，最终地址是相同的 原理与实现 核心原理 生成&amp;amp;转换 存储 映射 实现过程 用户先访问短网址，短网址将自动请求至短链服务器 短链服务器收到请求后，在映射中通过短网址查找原始长链 服务端将原始长链以302或301状态码返回给用户 用户浏览器收到后重定向到原始长链 生成短链主要有两种方式，哈希和ID生成器。&#xA;哈希 哈希算法 哈希算法可以将一个不管多长的字符串，转化成一个长度固定的哈希值，所以可以利用哈希算法，来生成短网址。&#xA;常用的哈希算法如MD5、SHA、MurMurHash、CRC32等。&#xA;短链不需要考虑反向解密难度，只需要考虑计算速度快、冲突概率小即可。&#xA;目前应用比较广泛非加密算法是2008 年被发明的MurmurHash，据资料显示，现在已经广泛应用到 Redis、MemCache、Cassandra、HBase、Lucene等软件中，MurmurHash算法具体实现可自行去了解，此处不展开（因为我懂得不多）。&#xA;MurmurHash 计算可选长度128位、32位等，位数多碰撞的概率就小，如果短链系统用的人不多，可以选择32位，这样生成的短链更短。&#xA;短链服务端接收到生成的请求后，可以把长链做 MurmurHash 计算，可以得到的一个哈希值，将哈希值与短链域名拼接，即可得到完整短链，如： t.cn/111111111&#xA;进制转换 如上所示，MurmurHash计算后得到的结果并不算短，我们可以优化一下，常用的方式是将10进制转换成62进制。 10进制转换62进制的逻辑就是，一直循环用62取余然后倒序：&#xA;最终 t.cn/111111111 用62进制表示的短链就是 t.cn/7WD4h 。&#xA;假设生成6位字符的短链： 10进制 最大只能生成 10 ^ 6 - 1 = 999999个 16进制 最大只能生成 16 ^ 6 - 1 = 16777215个 62进制 最大竟能生成 62 ^ 6 - 1 = 56800235583个 A-Z a-z 0-9 刚好等于62位。</description>
    </item>
    <item>
      <title>大厂面试复盘</title>
      <link>https://blog.hanyu.me/growing/1/</link>
      <pubDate>Fri, 25 Feb 2022 00:19:49 +0800</pubDate>
      <guid>https://blog.hanyu.me/growing/1/</guid>
      <description>面试题： 2021年末面试题(一些不好言说的原因，需要申请权限)&#xA;背景 哈喽，我是Damon，现在是2022了，年前11月上旬到12月上旬一直在面试，年后很多很多人催着我出面经，现在我一说话就问我“面经好了没，我等着去面试” 🤣🤣🤣，所以赶了几个周末，一个字一个字的纯手敲总结，面试题、简历模板、薪酬对比模板在下面。&#xA;无论如何，老铁们先来个一键四连（关注公众号：韩宇Pro、点赞、在看、转发朋友圈）嘻嘻嘻我真不要脸。&#xA;公众号对话框回复 “西瓜西瓜” 可加我私人微信。&#xA;我先做个简单的自我介绍，我是90年出生，目前已经30+岁，2013年毕业于黑龙江科技大学，双非统本。实习的时候就来了北京，整体履历背景比较一般，好在我后期挺努力上进🤣。&#xA;2021年在线教育行业“大地震”，导致我在一家在线教育公司4年多，最终也是离开了，但我觉得这是我人生中最幸运的一个转折点。 我在之前公司最多时候带37个人的团队，这些年面试过非常多的人，所以今天会将我作为最近的面试者、以往的面试官的双重经验，结合起来做这份分享。&#xA;结果 经过一个半月多的辛酸历程，虽然中间很不幸赶上了很多公司年底人才盘点、HC审批很慢、互联网业务收缩等意外情况，但经过努力最终还是拿到了以下好的结果，真的很开心。&#xA;目前已经入职一家一线大厂，本想说出来和大家分享喜悦和兴奋。但我发现有些公众号博主会公开自己在哪家公司（让自己公号传播更快更有信服力），有些博主却不在文章中公开自己的公司信息（我不太清楚为什么），所以，没搞清楚是否合规之前，为了稳妥我先不在文章里透露了我所在的公司了。&#xA;这次面试主要offer历程如下：&#xA;感恩 感谢安琪拉的模拟面。 感谢达哥、晨哥、泽彬老师、芮哥、影哥、雷哥、米豆老师、见素老师、定骏老师、Ben、Jessie、大鹏老师、十一老师。 知遇之恩不会忘。&#xA;唠唠叨叨 下面我将按照面试前、面试中、面试后三个大阶段，加上这一个月的面试题汇总，来和大家分享。&#xA;拼了几个周末，纯手工码出这篇，全部来自我这段时间面试的真实的经历和自我复盘，请大哥大姐们笑纳，希望大家都能奔向一个好前程。&#xA;面试前 复习 有句屁话说的好“提升技术最快的时候永远是准备跳槽前”，如果想找一份期望中的公司和职位，面试前复习必不可少，除非你“天资聪慧骨骼清奇”，学习的路线和方式我觉得要看你对这次找工作的具体预期。以下基于普通资质普通能力的人。&#xA;绝对技巧1 ： 扩散式学习 因为大多数人都没有充足的时间系统性的进行学习，所以扩散式学习更有效果。&#xA;其实就是先去找面试题、面经、网上流传的核心知识点、岗位要求上的需求点，先看这些核心，再向四周扩散。&#xA;举个例子，有道面试题：Redis执行BGSAVE的时候，fork出的子进程是拷贝了一份完整的内存数据出来吗？&#xA;基于这个例子，除了要看这道题本身的答案，还应该向外扩散，去复习Redis的持久化策略。&#xA;绝对技巧2： 预判式学习 假设你一直是一名Java开发人员，如果你下个星期面试的岗位还是Java开发，那肯定是狠狠的复习Java基础、生态等。&#xA;但是如果你面试的岗位是Java转Go开发，这时候你应该着重准备语言相关性低的技术，比如MySQL、Kafka、Redis、Linux等，因为你又不会Go，而面试官可能对Java也未必熟悉，这种情况下面试官问语言生态相关的考题的可能性较低。&#xA;你得把宝贵的时间投入到产出最大地方。&#xA;简历 简历真是太重要，绝对的敲门砖，能不能有面试邀约主要看简历水准了。&#xA;我的简历模板、安琪拉的简历模板下载：： http://jump.hanyu.cool&#xA;首先简历一定让重点变得更明显，让无关的直接消失。&#xA;个人技能：这里直接使用一行简单罗列你的技术栈名词，不要写什么精通还是熟悉之类的，不要堆砌很多行技能列表，个人技能这一栏只有两点用处，第一就是让不懂技术的HR能够根据岗位需求，匹配你简历中的关键词，第二就是面试官对你技术栈有个大概了解 自我介绍：不要写什么抗压能力强、什么沟通协调好、什么有责任心之类的一堆形容词，有人说“自我介绍”不重要，恰恰相反，我觉得“自我介绍”最重要，这里直接简明扼要的突出你的最大优势，例如： 自研一套xxx框架，2021年给公司节省了300万的研发成本； 或者 带领30人团队3个月内通过xxx、xxx等方式拿下10%业绩增长； 曾获得年度杰出员工奖（仅一人）； 作为技术不要像传统简历一样将公司经历和项目经历分开，而是直接合并在一起 如果你的公司有知名度的产品，那么将公司名和产品名合并写，例如：北京智者天下科技有限公司（知乎），HR和面试官看简历最主要看的就是你的公司背景 简历不要有错别字，会给面试官非常不认真不严谨的负面感受 投递 简历的渠道无非就是这么几种，招聘平台、内推，猎头，官网投。&#xA;关于内推 按照我这次的经验和感受，感觉几年以前内推是效果最好的（公司成本低且有员工背书），但现在由于内推泛滥，很多人在脉脉上以内推为副业（我也想这么干），导致现在内推到约面的效率远不如招聘平台直接投递和找猎头的约面效率高。&#xA;如果你现在身边有朋友在你期望去的公司，尽量找朋友中职级和影响力最高的那个帮你内推。如果你不认识可以帮你内推的人，可以去脉脉或者其他平台上找相应公司的员工帮你内推，主要你的简历没有在对方公司的简历库内，他们内推成功都是可以拿到内推奖金的。且尽量找自己目标岗位对应部门的人内推。学历低一些、跳槽比较频繁的情况找靠谱的人内推是比较合适的，如果认识HR和业务甚至可以帮你解释一下。&#xA;关于招聘平台 据我自己的感受，脉脉上猎头和大厂员工比较多，BOSS上的HR比较多，投递的时候一定要看清楚JD，投递的时候一定要看清楚JD，投递的时候一定要看清楚JD，重要的事情三遍不止。&#xA;JD上一般都会写清楚是什么业务线、做什么相关工作，一家公司可能有非常非常多的JD放出来，你投递了某一个简历可能就会被公司内部简历库锁定，其他的岗位你就不能投递了，所以一定要慎重选择好自己期望的岗位。&#xA;还有一点，很多大厂都是，一旦你在某一个岗位面试通过定薪定级，就算你不满意拒掉重新面这家公司，依然会采用第一次的定薪定级。&#xA;关于猎头 我觉得如果你对自己很没信心，又没有一些人脉资源，也没有一些软性的谈判技巧，那你可以尝试让猎头帮你，他们一般会提供一些过往面试人员的面试经验和对应公司的一些特殊要求给到你，从软性素质这里他们也会给你一些专业的建议，进度跟踪这里是猎头的强项，会很快拿到结果，起码不会出现那种HR连消息都不回的情况。&#xA;关于官网投递 官网投递我从没有使用过，所以我就不发表建议啦。&#xA;我的投递方式 我这次是80%自己投递+10%猎头推荐+10%内推。&#xA;关于大厂职级对标 勉强可以参考一下 https://duibiao.info，这个只能大概的参考，并不是很准。&#xA;一点投递建议 每一次投递都要慎重，如果是你心仪的公司就更要慎之又慎，基本上大公司都是有自己的简历库的，每面一次都会有相应的面试评价在简历库中记录，后续的面试官都是能够看到你过往的所有评价的。&#xA;所以，心仪的公司，一定要做好准备再投递，千万别突然接到个面试电话就开始面，西瓜曾经就栽在这方面过，对后续的影响很大。&#xA;面试中 约面 使用日历 一定要使用日历，我推荐你用滴答清单，不然面试越来越多，时间点可能会随时变动，如果不用日历很容易忘记或者记错面试，那就尴尬了。</description>
    </item>
    <item>
      <title>浅尝MySQL索引</title>
      <link>https://blog.hanyu.me/tech/2/</link>
      <pubDate>Wed, 09 Feb 2022 17:28:32 +0800</pubDate>
      <guid>https://blog.hanyu.me/tech/2/</guid>
      <description>写在前面的废话 Hello，大家好，我是Damon，一年前我写了一篇文章，然后拖更至今。 这其中有自己懒惰、工作变动等因素，年前这段时间一直在求职面试，拿到了些一线大厂和一些独角兽的offer。这段时间面试的经验和学习的过程对我自己帮助很大，面经还在整理中，后续会发出来给大家做一个参考吧。&#xA;因为每家公司的面试官不同，出题也是千遍万化，所以有些基础的核心知识，必须要体系化的学习，今天写这篇MySQL索引相关的知识也都是面试必问，后面我也会把一些锁、事务等等相关知识点写出来。&#xA;从今天开始，也会持续更新啦。虽然这篇文章很八股很基础，但总要一点点来，不积跬步无以至千里。如果觉得西瓜不错，可以点击关注哦。&#xA;咱们一起成长吧！&#xA;什么是索引 索引是一种有序的数据结构，它的作用很多人形象的比喻为书的目录。&#xA;注：数据结构一般是指逻辑上数据的组织形式，就好像运动会时老师要班级里的同学按照某一种队形站位一样。&#xA;索引的用处 正因为索引是一种一种有序的数据组织形式，所以可以提高查询效率，也让排序行为变得简单。&#xA;索引的缺点 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行insert、update和delete。因为更新表时，不仅要保存数据，还要保存一下索引文件。 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会增长很快。 索引只是提高效率的一个因素，如果有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。 索引到底是个什么 其实索引就只是一个硬盘上的文件而已，例如，在InnoDB引擎下，索引其实就是如下MySQL相关目录下的一个后缀名为.ibd的文件。&#xA;注：&#xA;如果使用MyISAM存储引擎，数据库文件类型就包括.frm (表结构描述)、.MYD (表数据)、.MYI (索引)&#xA;如果使用InnoDB存储引擎，数据库文件类型就包括.frm (表结构描述)、ibdata1 (共享表空间)、.ibd (索引)&#xA;索引在MySQL架构体系位置 MySQL宏观层面可以大致分层如图：&#xA;如上图可知，MySQL的索引其实是属于引擎层的数据结构。&#xA;MySQL支持的索引类型是和引擎息息相关的：&#xA;索引类型的比较 现在MySQL默认的存储引擎使用的是InnoDB，也是大多数公司的选择，而InnoDB的索引数据结构就是B+tree.每一个索引在InnoDB里面对应一棵B+树。&#xA;B+tree和B-tree(B-tree读B树不读B减树) B+tree是B-Tree的一个变种，B+tree只在叶子节点存储数据，而B-tree非叶子节点也存储数据，以下是实验链接：&#xA;B-tree B+tree&#xA;因此，B+tree 单个节点的数量更小，在相同的磁盘 IO 下能查询更多的节点。&#xA;另外 B+tree 叶子节点采用双向链表结构，适合MySQL中常见的基于范围的顺序检索场景，而 B-tree 无法做到这一点。&#xA;B+tree 索引与 Hash 表 基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。&#xA;但范围查询是MySQL数据库中常见的场景，而Hash表不适合做范围查询，Hash表更适合做等值查询。&#xA;B+tree索引结构图 数据页是什么 在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page），这部分非本文的重点内容，后续单开一篇来讲。&#xA;页（Pages）是mysql中磁盘和内存交换的基本单位，也是mysql管理存储空间的基本单位。&#xA;Buffer Pool 中存的就是一页一页的数据。再比如，当我们要查询的数据不在 Buffer Pool 中时，InnoDB 会将记录所在的页整个加载到 Buffer Pool 中去；同样的，当我们修改数据时，都需要将数据所在的数据页从磁盘读入到Buffer Pool中，然后在Buffer Pool中对其进行操作，操作完成后将 Buffer Pool 中的脏页刷入磁盘时，也是按照页为单位刷入磁盘的。同一个数据库实例的所有表空间都有相同的页大小，默认情况下，表空间中的页大小都为 16KB，当然也可以通过改变源码中的页大小参数重新编译进行修改，不同的页大小最终也会导致区大小的不同。&#xA;当插入一行数据时，会将该数据页加载到Buffer Pool中，然后从空闲区域中拿出一部分空间分配给数据行区域，当空闲区域耗尽时，表示该数据页已经满了。</description>
    </item>
    <item>
      <title>分布式锁之电商防超卖的N&#43;1个坑</title>
      <link>https://blog.hanyu.me/tech/1/</link>
      <pubDate>Tue, 23 Mar 2021 22:40:49 +0800</pubDate>
      <guid>https://blog.hanyu.me/tech/1/</guid>
      <description>大家好，我是Damon。&#xA;今天和同事讨论库存防超卖问题，发现虽然只是简单的库存扣减场景，却隐藏着很多坑，一不小心就容易翻车，让我来填平这些坑。&#xA;单实例环境 一般电商体系防止库存超卖，主要有以下几种方式：&#xA;防止库存超卖，最先想到的可能就是「锁」，如果是一些单实例部署的库存服务，大部分情况下我们可以使用以下锁或并发工具类：&#xA;这三个任何一个都可以保证同一单位时间只有一个线程能够进行库存扣减，废话不多说，上码！&#xA;/** * 库存扣减（伪代码 ReentrantLock ) * @param stockRequestDTO * @return Boolean */ public Boolean stockHandle(StockRequestDTO stockRequestDTO) { // 日志打印...校验...前置处理等... int stock = stockMapper.getStock(stockRequestDTO.getGoodsId()); reentrantLock.lock(); try { int result = stock &amp;gt; 0 ? stockMapper.updateStock(stockRequestDTO.getGoodsId(), --stock) : 0; return result &amp;gt; 0 ? true : false; } catch (SQLException e) { // 异常日志打印及处理... return false; } finally { reentrantLock.unlock(); } } /** * 库存扣减（伪代码 synchronized ) * @param stockRequestDTO * @return Boolean */ public synchronized Boolean stockHandle(StockRequestDTO stockRequestDTO){ // 执行业务逻辑.</description>
    </item>
  </channel>
</rss>
